<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Upside Down | Secure P2P</title>
    
    <!-- React & DOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>    
    
    <!-- Tailwind -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    
    <!-- QR Tools -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Import Fonts: Serif for titles (Benguiat-ish), Mono for data */
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Merriweather:wght@900&family=VT323&display=swap');
        
        :root {
            --st-red: #ff1515;
            --st-dark-red: #8a0000;
            --bg-dark: #050205;
            --ash-color: rgba(200, 200, 200, 0.4);
        }

        body {
            background-color: var(--bg-dark);
            color: #d1d5db;
            font-family: 'VT323', monospace; /* Retro terminal font */
            overflow: hidden;
            touch-action: manipulation;
        }

        /* Title Font */
        .font-title {
            font-family: 'Merriweather', serif;
            letter-spacing: -1px;
        }

        .st-glow {
            text-shadow: 
                0 0 5px var(--st-dark-red),
                0 0 10px var(--st-dark-red),
                0 0 20px var(--st-red);
        }
        
        .st-box-shadow {
            box-shadow: 0 0 15px rgba(255, 21, 21, 0.2);
        }

        .app-height {
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Atmosphere: Film Grain & Vignette */
        .atmosphere {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }
        .grain {
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            opacity: 0.15;
        }
        .vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, transparent 50%, #000 100%);
            opacity: 0.8;
        }

        /* Floating Ash Particles */
        .ash-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
            pointer-events: none;
        }
        .ash {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--ash-color);
            border-radius: 50%;
            animation: float 10s infinite linear;
        }
        @keyframes float {
            0% { transform: translateY(100vh) translateX(0); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.8; }
            100% { transform: translateY(-10vh) translateX(20px); opacity: 0; }
        }

        /* Red Scanline */
        .scanline {
            width: 100%; height: 3px;
            background: rgba(255, 0, 0, 0.5);
            position: absolute;
            animation: scan 3s linear infinite;
            box-shadow: 0 0 10px var(--st-red);
            z-index: 50;
            pointer-events: none;
            opacity: 0.6;
        }
        @keyframes scan { 0% { top: 0%; opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

        /* UI Panels */
        .glass-panel {
            background: rgba(20, 10, 20, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 50, 50, 0.2);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        /* Utilities */
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }

        /* Chat Bubbles */
        .msg-bubble { 
            max-width: 85%; 
            padding: 8px 12px; 
            border-radius: 4px; 
            position: relative; 
            word-break: break-word; 
            line-height: 1.4;
            font-size: 1.1rem;
        }
        .msg-me { 
            background: rgba(139, 0, 0, 0.6); /* Dark Red */
            color: #ffd1d1; 
            border-right: 3px solid var(--st-red);
            margin-left: auto; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.5); 
        }
        .msg-other { 
            background: rgba(30, 30, 40, 0.8); 
            color: #d1d5db; 
            border-left: 3px solid #555;
            margin-right: auto; 
        }
        
        /* System Pills */
        .msg-sys { display: flex; justify-content: center; width: 100%; margin: 16px 0; opacity: 0.9; }
        .sys-pill { 
            background: #000; 
            color: var(--st-red); 
            font-size: 14px; 
            padding: 4px 12px; 
            border: 1px solid var(--st-red);
            box-shadow: 0 0 5px var(--st-red);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }

        /* Recording Pulse (Red) */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
        }

        /* Flicker Animation */
        .flicker { animation: flicker 3s infinite; }
        @keyframes flicker {
            0%, 19.999%, 22%, 62.999%, 64%, 64.999%, 70%, 100% { opacity: 0.99; }
            20%, 21.999%, 63%, 63.999%, 65%, 69.999% { opacity: 0.4; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- CONFIG ---
        const CHUNK_SIZE = 250;
        const ICE_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const FILE_CHUNK_SIZE = 16384; 
        const EMOJIS = ["üëç", "‚ù§Ô∏è", "üö≤", "üî¶", "üßá", "üé≤", "üëπ", "ü©∏", "üå≤", "üìª", "üëΩ", "üëª", "üßü", "üï∏Ô∏è", "‚ö°", "üî•"];
        
        // --- UTILS ---
        const buf2hex = (buf) => [...new Uint8Array(buf)].map(x => x.toString(16).padStart(2, '0')).join('');
        const hex2buf = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))).buffer;
        
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return window.btoa(binary);
        };
        const base64ToArrayBuffer = (base64) => {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
            return bytes.buffer;
        };

        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        // --- ASH PARTICLES COMPONENT ---
        const AshParticles = () => {
            const particles = Array.from({ length: 30 });
            return (
                <div className="ash-container">
                    {particles.map((_, i) => (
                        <div key={i} className="ash" style={{
                            left: `${Math.random() * 100}%`,
                            animationDelay: `${Math.random() * 5}s`,
                            animationDuration: `${5 + Math.random() * 10}s`,
                            opacity: Math.random() * 0.7
                        }}></div>
                    ))}
                </div>
            );
        };

        // --- COMPONENTS ---

        const Icon = ({ name, size = 24, className, onClick }) => {
            const ref = useRef(null);

            useEffect(() => {
                if(!window.lucide || !ref.current) return;
                const el = document.createElement('i');
                el.setAttribute('data-lucide', name);
                ref.current.innerHTML = '';
                ref.current.appendChild(el);
                window.lucide.createIcons({ root: ref.current, attrs: { width: size, height: size } });
            }, [name, size]);

            return (
                <span 
                    ref={ref} 
                    onClick={onClick} 
                    className={`inline-flex items-center justify-center ${className || ''}`}
                    style={{ cursor: onClick ? 'pointer' : 'default' }}
                ></span>
            );
        };

        const QRAnimator = ({ data, label }) => {
            const [index, setIndex] = useState(0);
            const canvasRef = useRef(null);
            
            const chunks = useMemo(() => {
                if(!data) return [];
                const str = typeof data === 'string' ? data : JSON.stringify(data);
                const b64 = btoa(str); 
                const total = Math.ceil(b64.length / CHUNK_SIZE);
                const arr = [];
                for(let i=0; i<total; i++) {
                    arr.push(`SL:${i}:${total}:${b64.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE)}`);
                }
                return arr;
            }, [data]);

            useEffect(() => {
                if(chunks.length <= 1) return;
                const interval = setInterval(() => {
                    setIndex(prev => (prev + 1) % chunks.length);
                }, 250);
                return () => clearInterval(interval);
            }, [chunks]);

            useEffect(() => {
                if(canvasRef.current && chunks.length > 0) {
                    new QRious({
                        element: canvasRef.current,
                        value: chunks[index],
                        size: 250,
                        level: 'L',
                        foreground: '#000',
                        background: '#e5e7eb' // Light gray instead of pure white for retro feel
                    });
                }
            }, [index, chunks]);

            return (
                <div className="flex flex-col items-center bg-zinc-900 p-4 border-2 border-red-900 rounded-sm shadow-[0_0_20px_rgba(255,0,0,0.3)]">
                    <canvas ref={canvasRef} className="rounded-sm mb-2 opacity-90 sepia-[.3]"></canvas>
                    <div className="w-full bg-black h-2 rounded-none overflow-hidden border border-red-900">
                        <div className="h-full bg-red-600 transition-all duration-100" 
                             style={{width: `${((index+1)/chunks.length)*100}%`}}></div>
                    </div>
                    <p className="text-red-500 font-mono text-lg mt-2 font-bold tracking-widest">{label} ({index+1}/{chunks.length})</p>
                </div>
            );
        };

        const QRScanner = ({ onScan }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [status, setStatus] = useState("SEARCHING FREQUENCY...");

            const scanLoop = useCallback(() => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                if(!video || !canvas) return;

                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    
                    if (code && code.data.startsWith('SL:')) {
                        setStatus("SIGNAL LOCKED");
                        onScan(code.data);
                    } else {
                        setStatus("SEARCHING FREQUENCY...");
                    }
                }
                requestAnimationFrame(scanLoop);
            }, [onScan]);

            useEffect(() => {
                let stream = null;
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        if(videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(e => console.error(e));
                            requestAnimationFrame(scanLoop);
                        }
                    })
                    .catch(err => setStatus("NO CAMERA FEED"));
                return () => { if(stream) stream.getTracks().forEach(t => t.stop()); };
            }, [scanLoop]);

            return (
                <div className="relative w-full max-w-sm aspect-square bg-black overflow-hidden border-4 border-red-900 shadow-2xl">
                    <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover opacity-60 sepia contrast-125" muted playsInline></video>
                    <canvas ref={canvasRef} className="hidden"></canvas>
                    <div className="scanline"></div>
                    {/* Retro Camera Overlay */}
                    <div className="absolute top-4 left-4 text-red-500 font-mono text-xl animate-pulse">REC ‚óè</div>
                    <div className="absolute bottom-4 left-0 right-0 text-center">
                        <span className={`text-lg px-4 py-1 font-mono font-bold tracking-widest transition-colors ${status === "SIGNAL LOCKED" ? "bg-red-600 text-black" : "bg-black text-red-500 border border-red-900"}`}>{status}</span>
                    </div>
                </div>
            );
        };

        const IdentityModal = ({ fingerprint, onClose }) => {
            if (!fingerprint) return null;
            return (
                <div className="fixed inset-0 z-[100] bg-black/90 flex items-center justify-center p-4 fade-in">
                    <div className="bg-zinc-900 border-2 border-red-800 p-8 max-w-sm w-full text-center relative shadow-[0_0_50px_rgba(200,0,0,0.2)]">
                        <button onClick={onClose} className="absolute top-2 right-2 p-2 text-red-500 hover:text-white">
                            <Icon name="x" size={24} />
                        </button>
                        <div className="w-16 h-16 bg-red-900/20 rounded-full flex items-center justify-center mx-auto mb-4 border border-red-500 animate-pulse">
                            <Icon name="fingerprint" size={32} className="text-red-500" />
                        </div>
                        <h3 className="text-2xl font-bold text-red-500 mb-2 font-title tracking-wide uppercase">ID Verification</h3>
                        <p className="text-zinc-500 text-lg mb-6 font-mono">Confirm peer signature.</p>
                        <div className="bg-black p-6 border border-red-900 mb-6">
                            <div className="text-5xl mb-4 tracking-widest filter drop-shadow-[0_0_5px_rgba(255,0,0,0.8)]">{fingerprint.emoji}</div>
                            <div className="font-mono text-red-400 text-xl tracking-[0.2em] break-all">{fingerprint.hex}</div>
                        </div>
                        <button onClick={onClose} className="w-full py-3 bg-red-900 hover:bg-red-700 border border-red-500 text-red-100 font-bold text-xl uppercase tracking-widest transition-colors font-mono">Verified</button>
                    </div>
                </div>
            );
        };

        // --- CALL UI COMPONENT ---
        const CallOverlay = ({ status, localStream, remoteStream, onAnswer, onHangup, isVideo, onToggleMute, onToggleVideo }) => {
            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);
            
            const [isMuted, setIsMuted] = useState(false);
            const [isCameraOff, setIsCameraOff] = useState(false);

            useEffect(() => {
                if (localVideoRef.current && localStream) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream, isCameraOff]); 

            useEffect(() => {
                if (remoteVideoRef.current && remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                    remoteVideoRef.current.play().catch(e => console.log("Auto-play err", e));
                }
            }, [remoteStream]);

            const handleMuteClick = () => {
                const success = onToggleMute();
                if(success) setIsMuted(prev => !prev);
            };

            const handleVideoClick = () => {
                const success = onToggleVideo();
                if(success) setIsCameraOff(prev => !prev);
            };

            if (status === 'IDLE') return null;

            const remoteHasVideo = remoteStream && remoteStream.getVideoTracks().length > 0;

            return (
                <div className="fixed inset-0 z-[70] bg-black flex flex-col items-center justify-center w-screen h-screen">
                    
                    {/* Atmosphere */}
                    <div className="atmosphere"><div className="grain"></div><div className="vignette"></div></div>

                    {/* Main Video/Audio Container - Full Screen */}
                    <div className="relative w-full h-full flex items-center justify-center">
                        
                        {/* Remote Stream Layer */}
                        <video 
                            ref={remoteVideoRef} 
                            autoPlay 
                            playsInline 
                            className="w-full h-full object-cover absolute inset-0 z-0 opacity-80 contrast-125 sepia-[0.4]" 
                        />

                        {/* Audio-only Avatar Visualization */}
                        {!remoteHasVideo && (
                            <div className="absolute inset-0 w-full h-full flex flex-col items-center justify-center bg-black z-10">
                                <div className="relative">
                                    <div className={`absolute inset-0 bg-red-600 rounded-full blur-3xl opacity-20 ${status === 'ACTIVE' ? 'animate-pulse' : ''}`}></div>
                                    <div className="w-48 h-48 rounded-full border-4 border-red-900 bg-black flex items-center justify-center relative z-10 shadow-[0_0_50px_rgba(255,0,0,0.3)]">
                                        <Icon name="radio" size={80} className="text-red-500" />
                                    </div>
                                </div>
                                <p className="text-red-500 font-mono text-xl uppercase mt-8 animate-pulse tracking-[0.3em] flicker">
                                    {status === 'ACTIVE' ? 'SIGNAL CONNECTED' : status === 'OUTGOING' ? 'SENDING SIGNAL...' : 'CONNECTING...'}
                                </p>
                            </div>
                        )}

                        {/* Local Video (PiP) */}
                        {localStream && isVideo && !isCameraOff && (
                            <div className="absolute top-6 right-6 w-32 h-48 sm:w-48 sm:h-64 bg-black border-2 border-red-900 z-20 shadow-2xl">
                                <video ref={localVideoRef} autoPlay playsInline muted className="w-full h-full object-cover transform scale-x-[-1] opacity-90 contrast-125 sepia-[0.3]" />
                            </div>
                        )}

                        {/* Controls Overlay */}
                        <div className="absolute bottom-0 w-full p-8 pb-12 bg-gradient-to-t from-black via-black/80 to-transparent z-30 pb-safe">
                            <div className="max-w-md mx-auto">
                                <div className="text-center mb-8">
                                    <h3 className="text-4xl font-title text-red-500 mb-2 st-glow">
                                        {status === 'INCOMING' ? 'INCOMING TRANSMISSION' : status === 'OUTGOING' ? 'DIALING HAWKINS...' : 'CONNECTED'}
                                    </h3>
                                    <div className="text-zinc-500 font-mono text-sm font-bold tracking-widest uppercase flex items-center justify-center gap-2">
                                        {status === 'ACTIVE' && <div className="w-3 h-3 bg-red-600 rounded-full animate-pulse"></div>}
                                        {status === 'ACTIVE' ? 'ENCRYPTED CHANNEL' : 'ESTABLISHING LINK...'}
                                    </div>
                                </div>

                                <div className="flex items-center justify-center gap-8">
                                    {status === 'INCOMING' ? (
                                        <>
                                            <button onClick={onHangup} className="flex flex-col items-center gap-2 group">
                                                <div className="p-5 bg-black border-2 border-zinc-700 text-zinc-500 rounded-full group-hover:border-red-500 group-hover:text-red-500 transition-all">
                                                    <Icon name="phone-off" size={32} />
                                                </div>
                                                <span className="text-xs font-bold text-zinc-500 uppercase tracking-wider">Ignore</span>
                                            </button>

                                            <button onClick={onAnswer} className="flex flex-col items-center gap-2 group">
                                                <div className="p-5 bg-red-700 text-black border-2 border-red-500 rounded-full shadow-[0_0_20px_rgba(255,0,0,0.5)] group-hover:bg-red-600 group-hover:scale-110 transition-all animate-bounce">
                                                    <Icon name="phone" size={32} />
                                                </div>
                                                <span className="text-xs font-bold text-red-500 uppercase tracking-wider">Answer</span>
                                            </button>
                                        </>
                                    ) : (
                                        <>
                                            <button 
                                                onClick={handleMuteClick} 
                                                className={`p-5 rounded-full transition-all border-2 ${
                                                    isMuted 
                                                        ? 'bg-red-900 border-red-600 text-white' 
                                                        : 'bg-black border-zinc-700 text-zinc-400 hover:border-red-500 hover:text-red-500'
                                                }`}
                                            >
                                                <Icon key={isMuted ? "mic-off" : "mic"} name={isMuted ? "mic-off" : "mic"} size={28} />
                                            </button>
                                            
                                            <button onClick={onHangup} className="p-6 bg-red-700 rounded-full text-black shadow-xl hover:bg-red-600 hover:scale-110 transition-all border-4 border-black">
                                                <Icon name="phone-off" size={36} />
                                            </button>

                                            {isVideo && (
                                                <button 
                                                    onClick={handleVideoClick} 
                                                    className={`p-5 rounded-full transition-all border-2 ${
                                                        isCameraOff 
                                                            ? 'bg-red-900 border-red-600 text-white' 
                                                            : 'bg-black border-zinc-700 text-zinc-400 hover:border-red-500 hover:text-red-500'
                                                    }`}
                                                >
                                                    <Icon key={isCameraOff ? "video-off" : "video"} name={isCameraOff ? "video-off" : "video"} size={28} />
                                                </button>
                                            )}
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- CAMERA COMPONENT ---
        const CameraModal = ({ onClose, onCapture }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const [stream, setStream] = useState(null);
            const [mode, setMode] = useState('PHOTO'); // PHOTO or VIDEO
            const [isRecording, setIsRecording] = useState(false);
            const [preview, setPreview] = useState(null); // { type: 'image'|'video', url, blob }
            const [timer, setTimer] = useState(0);

            useEffect(() => {
                let s = null;
                navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" }, 
                    audio: true 
                }).then(mediaStream => {
                    s = mediaStream;
                    setStream(mediaStream);
                    if(videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.play();
                    }
                }).catch(err => console.error("Cam Access Denied", err));
                return () => { if(s) s.getTracks().forEach(t => t.stop()); }
            }, []);

            useEffect(() => {
                let interval;
                if(isRecording) {
                    interval = setInterval(() => setTimer(t => t+1), 1000);
                } else {
                    setTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecording]);

            const takePhoto = () => {
                if(!videoRef.current || !canvasRef.current) return;
                const w = videoRef.current.videoWidth;
                const h = videoRef.current.videoHeight;
                canvasRef.current.width = w;
                canvasRef.current.height = h;
                const ctx = canvasRef.current.getContext('2d');
                ctx.drawImage(videoRef.current, 0, 0, w, h);
                canvasRef.current.toBlob(blob => {
                    setPreview({ type: 'image', url: URL.createObjectURL(blob), blob });
                }, 'image/jpeg', 0.85);
            };

            const toggleVideo = () => {
                if(isRecording) {
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                } else {
                    const chunks = [];
                    const mr = new MediaRecorder(stream, { mimeType: 'video/webm' });
                    mr.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                    mr.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        setPreview({ type: 'video', url: URL.createObjectURL(blob), blob });
                    };
                    mr.start();
                    mediaRecorderRef.current = mr;
                    setIsRecording(true);
                }
            };

            const handleSend = () => {
                if(preview) {
                    const name = preview.type === 'image' ? `photo_${Date.now()}.jpg` : `video_${Date.now()}.webm`;
                    const type = preview.type === 'image' ? 'image/jpeg' : 'video/webm';
                    onCapture(preview.blob, name, type);
                    onClose();
                }
            };

            const retake = () => {
                setPreview(null);
            };

            return (
                <div className="fixed inset-0 z-[60] bg-black flex flex-col app-height items-center justify-center p-4">
                    <div className="w-full max-w-5xl h-full max-h-[90vh] flex flex-col relative bg-black border-2 border-red-900 shadow-2xl overflow-hidden">
                        {/* Header */}
                        <div className="p-4 flex justify-between items-center bg-black/80 absolute top-0 w-full z-10 pb-safe backdrop-blur-sm border-b border-red-900/30">
                            <button onClick={onClose} className="text-red-500 hover:text-white transition-colors"><Icon name="x" /></button>
                            {isRecording && <div className="text-red-600 font-mono font-bold animate-pulse text-lg">‚óè REC {formatTime(timer)}</div>}
                            <div className="w-8"></div>
                        </div>

                        {/* Main View */}
                        <div className="flex-1 relative bg-zinc-900 flex items-center justify-center overflow-hidden">
                            {!preview ? (
                                <>
                                    <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover sepia-[0.3] contrast-125" muted playsInline></video>
                                    <canvas ref={canvasRef} className="hidden"></canvas>
                                    <div className="absolute inset-0 pointer-events-none flex items-center justify-center opacity-50">
                                        <div className="w-64 h-64 border-2 border-red-500/30"></div>
                                        <div className="w-2 h-2 bg-red-500 rounded-full"></div>
                                    </div>
                                </>
                            ) : (
                                <div className="relative w-full h-full bg-black flex items-center justify-center">
                                    {preview.type === 'image' ? 
                                        <img src={preview.url} className="max-w-full max-h-full object-contain sepia-[0.3]" alt="preview" /> : 
                                        <video src={preview.url} controls className="max-w-full max-h-full object-contain sepia-[0.3]" />
                                    }
                                </div>
                            )}
                        </div>

                        {/* Controls */}
                        <div className="bg-black border-t border-red-900 flex items-center justify-around pb-safe py-6">
                            {!preview ? (
                                <>
                                    <div className="flex gap-4">
                                        <button onClick={() => setMode('PHOTO')} className={`text-lg font-mono font-bold ${mode === 'PHOTO' ? 'text-red-500 underline underline-offset-4' : 'text-zinc-600'} hover:text-red-400 transition-colors`}>PHOTO</button>
                                        <button onClick={() => setMode('VIDEO')} className={`text-lg font-mono font-bold ${mode === 'VIDEO' ? 'text-red-500 underline underline-offset-4' : 'text-zinc-600'} hover:text-red-400 transition-colors`}>VIDEO</button>
                                    </div>
                                    <button 
                                        onClick={mode === 'PHOTO' ? takePhoto : toggleVideo}
                                        className={`w-20 h-20 rounded-full border-4 border-zinc-700 flex items-center justify-center transition-all cursor-pointer hover:border-red-500 ${isRecording ? 'bg-red-900 scale-105' : 'bg-transparent active:scale-95'}`}
                                    >
                                        <div className={`rounded-full transition-all ${mode === 'PHOTO' ? 'bg-red-500 w-16 h-16' : 'bg-red-600 w-12 h-12'}`}></div>
                                    </button>
                                    <div className="w-12"></div>
                                </>
                            ) : (
                                <div className="flex w-full justify-around items-center">
                                    <button onClick={retake} className="text-zinc-400 font-bold hover:text-white transition-colors uppercase font-mono tracking-wider">Retake</button>
                                    <button onClick={handleSend} className="bg-red-700 text-black px-10 py-3 rounded-sm font-bold text-xl hover:bg-red-600 hover:scale-105 transition-all shadow-[0_0_15px_rgba(255,0,0,0.4)] font-mono uppercase">Send</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [view, setView] = useState('HOME');
            const [role, setRole] = useState(null);
            const [logs, setLogs] = useState([]);
            const [msgText, setMsgText] = useState("");
            const [messages, setMessages] = useState([]);
            const [showVerify, setShowVerify] = useState(false);
            const [fileProgress, setFileProgress] = useState(0); 
            const [showCamera, setShowCamera] = useState(false);
            const [showEmoji, setShowEmoji] = useState(false);
            
            // Audio Recording State
            const [isRecordingAudio, setIsRecordingAudio] = useState(false);
            const [audioTimer, setAudioTimer] = useState(0);
            const audioRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // WebRTC Refs
            const pc = useRef(null);
            const dc = useRef(null);
            const candidates = useRef([]);
            
            // Crypto Refs
            const keys = useRef({ rsa: null, ecdh: null });
            const sessionKey = useRef(null);
            const fingerprint = useRef(null);
            const incomingFiles = useRef({});
            const fileInputRef = useRef(null);
            const chatEndRef = useRef(null);

            // Signaling State
            const [localSignal, setLocalSignal] = useState(null);
            const scannedChunks = useRef(new Map());
            const [scanProgress, setScanProgress] = useState(0);

            // Call State
            const [callStatus, setCallStatus] = useState('IDLE'); // IDLE, OUTGOING, INCOMING, ACTIVE
            const [localStream, setLocalStream] = useState(null);
            const localStreamRef = useRef(null);
            const [remoteStream, setRemoteStream] = useState(null);
            const [isVideoCall, setIsVideoCall] = useState(false);
            const pendingOffer = useRef(null);

            // Initial Key Gen
            useEffect(() => {
                const initKeys = async () => {
                    keys.current.rsa = await window.crypto.subtle.generateKey(
                        { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                        true, ["encrypt", "decrypt"]
                    );
                    keys.current.ecdh = await window.crypto.subtle.generateKey(
                        { name: "ECDH", namedCurve: "P-256" },
                        true, ["deriveKey", "deriveBits"]
                    );
                    addLog("CRYPTO_SYSTEM_INIT...");
                };
                initKeys();
            }, []);

            useEffect(() => {
                if (chatEndRef.current) chatEndRef.current.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            useEffect(() => {
                let interval;
                if(isRecordingAudio) {
                    interval = setInterval(() => setAudioTimer(t => t+1), 1000);
                } else {
                    setAudioTimer(0);
                }
                return () => clearInterval(interval);
            }, [isRecordingAudio]);

            const addLog = (txt) => setLogs(p => [...p.slice(-4), txt]);

            // WebRTC Setup
            const createPeer = useCallback(() => {
                const peer = new RTCPeerConnection(ICE_SERVERS);
                peer.onicecandidate = (e) => { 
                    if (e.candidate) {
                        if (dc.current && dc.current.readyState === 'open') {
                             dc.current.send(JSON.stringify({ t: 'SIG_ICE', c: e.candidate }));
                        } else {
                            candidates.current.push(e.candidate); 
                        }
                    } 
                };
                peer.onconnectionstatechange = () => addLog(`CONN_STATE: ${peer.connectionState.toUpperCase()}`);
                peer.ontrack = (e) => {
                    const stream = e.streams[0] || new MediaStream([e.track]);
                    setRemoteStream(new MediaStream(stream.getTracks()));
                };
                pc.current = peer;
                return peer;
            }, []);

            const processSignal = useCallback(async (data) => {
                if (!pc.current) return;
                if(role === 'HOST' && data.type === 'answer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    addLog("REMOTE_DESC_SET");
                } else if (role === 'JOINER' && data.type === 'offer') {
                    await pc.current.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    data.candidates.forEach(c => pc.current.addIceCandidate(new RTCIceCandidate(c)));
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    await new Promise(r => setTimeout(r, 500)); 
                    setLocalSignal({
                        type: 'answer',
                        sdp: pc.current.localDescription,
                        candidates: candidates.current
                    });
                    setView('JOIN_WAIT');
                }
            }, [role]);

            const handleScannedChunk = useCallback((raw) => {
                const parts = raw.split(':');
                if(parts.length < 4) return;
                const idx = parseInt(parts[1]);
                const total = parseInt(parts[2]);
                const data = parts.slice(3).join(':');

                if(!scannedChunks.current.has(idx)) {
                    scannedChunks.current.set(idx, data);
                    setScanProgress(Math.round((scannedChunks.current.size / total) * 100));
                    if(scannedChunks.current.size === total) {
                        const fullB64 = Array.from({length: total}, (_, i) => scannedChunks.current.get(i)).join('');
                        try {
                            const jsonStr = atob(fullB64);
                            const signalData = JSON.parse(jsonStr);
                            addLog("SIGNAL_CAPTURED");
                            scannedChunks.current.clear();
                            processSignal(signalData);
                        } catch(e) {
                            console.error("Signal parse error", e);
                            addLog("SIGNAL_PARSE_ERR");
                        }
                    }
                }
            }, [processSignal]);

            const startHost = async () => {
                setRole('HOST');
                const peer = createPeer();
                dc.current = peer.createDataChannel("shadowlink");
                setupDataChannel(dc.current);
                const offer = await peer.createOffer();
                await peer.setLocalDescription(offer);
                await new Promise(r => setTimeout(r, 500));
                setLocalSignal({ type: 'offer', sdp: peer.localDescription, candidates: candidates.current });
                setView('HOST_WAIT');
            };

            const startJoin = () => {
                setRole('JOINER');
                const peer = createPeer();
                peer.ondatachannel = (e) => {
                    dc.current = e.channel;
                    setupDataChannel(dc.current);
                };
                setView('SCAN_HOST');
            };

            const setupDataChannel = (channel) => {
                channel.onopen = () => {
                    addLog("TUNNEL_OPEN");
                    initiateSecureHandshake();
                };
                channel.onmessage = async (e) => handlePacket(e.data);
            };

            const initiateSecureHandshake = async () => {
                const rsaPub = await window.crypto.subtle.exportKey("spki", keys.current.rsa.publicKey);
                const ecdhPub = await window.crypto.subtle.exportKey("raw", keys.current.ecdh.publicKey);
                dc.current.send(JSON.stringify({ t: 'HELLO', rsa: buf2hex(rsaPub), ecdh: buf2hex(ecdhPub) }));
            };

            const deriveSession = async (p) => {
                const peerRsa = await window.crypto.subtle.importKey("spki", hex2buf(p.rsa), { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);
                const peerEcdh = await window.crypto.subtle.importKey("raw", hex2buf(p.ecdh), { name: "ECDH", namedCurve: "P-256" }, true, []);
                
                const sharedBits = await window.crypto.subtle.deriveBits({ name: "ECDH", public: peerEcdh }, keys.current.ecdh.privateKey, 256);
                
                const hkdfKey = await window.crypto.subtle.importKey("raw", sharedBits, { name: "HKDF" }, false, ["deriveKey"]);
                sessionKey.current = await window.crypto.subtle.deriveKey(
                    { name: "HKDF", hash: "SHA-256", salt: new Uint8Array(), info: new TextEncoder().encode("ShadowLink") },
                    hkdfKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
                );

                const localRsaExp = await window.crypto.subtle.exportKey("spki", keys.current.rsa.publicKey);
                const remoteRsaExp = hex2buf(p.rsa);
                
                const localArr = new Uint8Array(localRsaExp);
                const remoteArr = new Uint8Array(remoteRsaExp);
                let first = localArr, second = remoteArr;
                
                for(let i=0; i<Math.min(localArr.length, remoteArr.length); i++) {
                    if (localArr[i] < remoteArr[i]) { first = localArr; second = remoteArr; break; }
                    if (localArr[i] > remoteArr[i]) { first = remoteArr; second = localArr; break; }
                }

                const totalLen = sharedBits.byteLength + first.length + second.length;
                const combined = new Uint8Array(totalLen);
                combined.set(new Uint8Array(sharedBits), 0);
                combined.set(first, sharedBits.byteLength);
                combined.set(second, sharedBits.byteLength + first.length);

                const fpHash = await window.crypto.subtle.digest("SHA-256", combined);
                const fpArr = new Uint8Array(fpHash);
                const emojis = ["ü¶á","üíÄ","üåô","üïØÔ∏è","üé≤","üìª","üßá","üö≤","üëπ","ü©∏","üå≤","üëª","üï∑Ô∏è","‚ö°","üî•","üëΩ"];
                let fpEmoji = "";
                for(let i=0; i<4; i++) fpEmoji += emojis[fpArr[i] % emojis.length];
                const fpHex = buf2hex(fpHash).substring(0, 8).toUpperCase();
                fingerprint.current = { emoji: fpEmoji, hex: fpHex };
                
                addLog(`SECURED: ${fpEmoji}`);
                setView('CHAT');
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `ENCRYPTED TUNNEL ESTABLISHED` }]);
            };

            const handlePacket = async (raw) => {
                try {
                    const p = JSON.parse(raw);
                    if (p.t === 'HELLO') await deriveSession(p);
                    else if (p.t === 'ENC') {
                        const pt = await decryptData(p.iv, p.d);
                        const text = new TextDecoder().decode(pt);
                        setMessages(prev => [...prev, { id: Date.now(), type: 'RX', text: text }]);
                    }
                    else if (p.t === 'SIG_OFFER') {
                        pendingOffer.current = p.sdp;
                        setIsVideoCall(p.video);
                        setCallStatus('INCOMING');
                    }
                    else if (p.t === 'SIG_ANSWER') {
                        if (pc.current.signalingState !== 'stable') {
                            await pc.current.setRemoteDescription(new RTCSessionDescription(p.sdp));
                            setCallStatus('ACTIVE');
                        }
                    }
                    else if (p.t === 'SIG_ICE') await pc.current.addIceCandidate(new RTCIceCandidate(p.c));
                    else if (p.t === 'CALL_END') endCallCleanup();
                    else if (p.t === 'FILE_HEADER') {
                        const pt = await decryptData(p.iv, p.meta);
                        const meta = JSON.parse(new TextDecoder().decode(pt));
                        incomingFiles.current[p.id] = { meta, chunks: [], receivedSize: 0, startTime: Date.now() };
                        setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `RECEIVING ${meta.name}...` }]);
                    }
                    else if (p.t === 'FILE_CHUNK') {
                        const fileCtx = incomingFiles.current[p.id];
                        if (fileCtx) {
                            const chunkData = base64ToArrayBuffer(p.d);
                            fileCtx.chunks.push({ idx: p.idx, data: chunkData });
                            fileCtx.receivedSize += chunkData.byteLength;
                            if (fileCtx.receivedSize >= fileCtx.meta.encSize) {
                                fileCtx.chunks.sort((a,b) => a.idx - b.idx);
                                const totalLen = fileCtx.chunks.reduce((acc, c) => acc + c.data.byteLength, 0);
                                const cipherBuffer = new Uint8Array(totalLen);
                                let offset = 0;
                                fileCtx.chunks.forEach(c => {
                                    cipherBuffer.set(new Uint8Array(c.data), offset);
                                    offset += c.data.byteLength;
                                });
                                try {
                                    const fileData = await window.crypto.subtle.decrypt(
                                        { name: "AES-GCM", iv: hex2buf(fileCtx.meta.iv) },
                                        sessionKey.current,
                                        cipherBuffer
                                    );
                                    const blob = new Blob([fileData], { type: fileCtx.meta.type });
                                    const url = URL.createObjectURL(blob);
                                    setMessages(prev => [...prev, { 
                                        id: Date.now(), type: 'FILE', text: fileCtx.meta.name, fileUrl: url, fileSize: fileCtx.meta.size, mimeType: fileCtx.meta.type
                                    }]);
                                    delete incomingFiles.current[p.id];
                                } catch(e) {
                                    console.error("Decrypt Fail", e);
                                    setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `DECRYPTION FAILED` }]);
                                }
                            }
                        }
                    }
                } catch(e) { console.error("Packet Error", e); }
            };

            const decryptData = async (ivHex, dataHex) => {
                return await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: hex2buf(ivHex) },
                    sessionKey.current,
                    hex2buf(dataHex)
                );
            };

            const sendMessage = async () => {
                if(!msgText.trim() || !sessionKey.current) return;
                const txt = msgText;
                setMsgText("");
                setMessages(prev => [...prev, { id: Date.now(), type: 'TX', text: txt }]);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const enc = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    sessionKey.current,
                    new TextEncoder().encode(txt)
                );
                dc.current.send(JSON.stringify({ t: 'ENC', iv: buf2hex(iv), d: buf2hex(enc) }));
            };

            const processAndSendFile = async (blob, fileName, fileType) => {
                 if (!sessionKey.current) return;
                const buffer = await blob.arrayBuffer();
                const fileIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedFile = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: fileIv }, sessionKey.current, buffer);
                const fileId = crypto.randomUUID();
                const metaRaw = JSON.stringify({ name: fileName, size: blob.size, type: fileType, iv: buf2hex(fileIv), encSize: encryptedFile.byteLength });
                const metaIv = window.crypto.getRandomValues(new Uint8Array(12));
                const encMeta = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: metaIv }, sessionKey.current, new TextEncoder().encode(metaRaw));
                dc.current.send(JSON.stringify({ t: 'FILE_HEADER', id: fileId, iv: buf2hex(metaIv), meta: buf2hex(encMeta) }));
                setMessages(prev => [...prev, { id: Date.now(), type: 'SYS', text: `TRANSMITTING ${fileName}...` }]);
                const totalChunks = Math.ceil(encryptedFile.byteLength / FILE_CHUNK_SIZE);
                let offset = 0;
                for (let i = 0; i < totalChunks; i++) {
                    const chunk = encryptedFile.slice(offset, offset + FILE_CHUNK_SIZE);
                    const b64Chunk = arrayBufferToBase64(chunk);
                    if (i % 10 === 0) await new Promise(r => setTimeout(r, 10)); 
                    dc.current.send(JSON.stringify({ t: 'FILE_CHUNK', id: fileId, idx: i, d: b64Chunk }));
                    offset += FILE_CHUNK_SIZE;
                    setFileProgress(Math.round(((i + 1) / totalChunks) * 100));
                }
                setFileProgress(0);
                const localUrl = URL.createObjectURL(blob);
                setMessages(prev => [...prev, { id: Date.now(), type: 'TX_FILE', text: fileName, fileUrl: localUrl, mimeType: fileType }]);
            };

            const handleFileSelect = (e) => {
                const file = e.target.files[0];
                if (file) processAndSendFile(file, file.name, file.type);
            };

            // --- CALLING LOGIC ---
            const startCall = async (video = false) => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: video });
                    setLocalStream(stream);
                    localStreamRef.current = stream; 
                    setIsVideoCall(video);
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    const offer = await pc.current.createOffer();
                    await pc.current.setLocalDescription(offer);
                    dc.current.send(JSON.stringify({ t: 'SIG_OFFER', sdp: offer, video }));
                    setCallStatus('OUTGOING');
                } catch(e) {
                    console.error("Call Error", e);
                    alert("ERR: CAMERA/MIC ACCESS DENIED");
                }
            };

            const answerCall = async () => {
                try {
                    let stream;
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: isVideoCall });
                    } catch(e) {
                        if (isVideoCall) stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                        else throw e;
                    }
                    setLocalStream(stream);
                    localStreamRef.current = stream; 
                    stream.getTracks().forEach(track => pc.current.addTrack(track, stream));
                    await pc.current.setRemoteDescription(new RTCSessionDescription(pendingOffer.current));
                    const answer = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answer);
                    dc.current.send(JSON.stringify({ t: 'SIG_ANSWER', sdp: answer }));
                    setCallStatus('ACTIVE');
                } catch(e) { console.error("Answer Error", e); }
            };

            const endCall = () => {
                dc.current.send(JSON.stringify({ t: 'CALL_END' }));
                endCallCleanup();
            };

            const endCallCleanup = () => {
                if(localStreamRef.current) {
                    localStreamRef.current.getTracks().forEach(t => t.stop());
                    localStreamRef.current = null;
                    setLocalStream(null);
                }
                if (pc.current) pc.current.getSenders().forEach(sender => pc.current.removeTrack(sender));
                setRemoteStream(null);
                setCallStatus('IDLE');
            };

            const toggleMute = () => {
                if(localStreamRef.current) {
                    const audioTrack = localStreamRef.current.getAudioTracks()[0];
                    if(audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        return true;
                    }
                }
                return false;
            };

            const toggleVideo = () => {
                if(localStreamRef.current) {
                    const videoTrack = localStreamRef.current.getVideoTracks()[0];
                    if(videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        return true;
                    }
                }
                return false;
            };

            const startAudioRecord = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    audioChunksRef.current = [];
                    recorder.ondataavailable = e => audioChunksRef.current.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                        processAndSendFile(blob, `voice_${Date.now()}.webm`, 'audio/webm');
                        stream.getTracks().forEach(t => t.stop());
                    };
                    recorder.start();
                    audioRecorderRef.current = recorder;
                    setIsRecordingAudio(true);
                } catch(e) { console.error("Mic Error", e); }
            };

            const stopAudioRecord = () => {
                if(audioRecorderRef.current && isRecordingAudio) {
                    audioRecorderRef.current.stop();
                    setIsRecordingAudio(false);
                }
            };

            const renderMediaContent = (m) => {
                const type = m.mimeType || '';
                const mediaStyle = "rounded-sm max-h-64 w-auto object-contain mt-2 border border-red-900 bg-black sepia-[0.3] contrast-125"; 
                if (type.startsWith('image/')) {
                    return (<a href={m.fileUrl} target="_blank" rel="noopener noreferrer" className="block cursor-pointer"><img src={m.fileUrl} className={mediaStyle} alt="content" /></a>);
                } else if (type.startsWith('video/')) {
                    return <video src={m.fileUrl} controls className={mediaStyle} />;
                } else if (type.startsWith('audio/')) {
                    return <div className="mt-2 w-full min-w-[200px]"><audio src={m.fileUrl} controls className="w-full h-8" /></div>;
                }
                return (<a href={m.fileUrl} download={m.text} className="mt-2 flex items-center justify-center gap-2 w-full py-2 bg-zinc-800 hover:bg-zinc-700 text-red-500 rounded-sm text-xs font-bold transition-colors uppercase tracking-widest border border-red-900"><Icon name="download" size={14} /> DOWNLOAD FILE</a>);
            };

            const renderHome = () => (
                <div className="flex flex-col items-center justify-center app-height p-6 space-y-8 animate-fade-in relative z-10">
                    <div className="w-full max-w-2xl mx-auto space-y-12">
                        <div className="text-center space-y-4">
                            <h1 className="text-6xl md:text-8xl font-title text-red-600 st-glow animate-pulse">UPSIDE DOWN</h1>
                            <p className="text-red-800 text-lg font-mono tracking-[0.2em] uppercase">Secure P2P Channel</p>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 w-full">
                            <button onClick={startHost} className="group relative overflow-hidden p-8 bg-transparent border-2 border-red-900 hover:border-red-500 transition-all text-left hover:shadow-[0_0_30px_rgba(255,0,0,0.4)]">
                                <div className="absolute inset-0 bg-red-900/10 group-hover:bg-red-900/30 transition-all"></div>
                                <h3 className="text-2xl font-bold text-red-500 flex items-center gap-3 font-title tracking-wider uppercase"><Icon name="radio-tower" size={24} /> Open The Gate</h3>
                                <p className="text-sm text-zinc-500 mt-2 font-mono">Create a signal beacon.</p>
                            </button>
                            <button onClick={startJoin} className="group relative overflow-hidden p-8 bg-transparent border-2 border-zinc-800 hover:border-red-500 transition-all text-left hover:shadow-[0_0_30px_rgba(255,0,0,0.4)]">
                                <div className="absolute inset-0 bg-zinc-900/10 group-hover:bg-red-900/30 transition-all"></div>
                                <h3 className="text-2xl font-bold text-zinc-400 group-hover:text-red-500 flex items-center gap-3 font-title tracking-wider uppercase"><Icon name="scan-line" size={24} /> Find Signal</h3>
                                <p className="text-sm text-zinc-500 mt-2 font-mono">Scan for a frequency.</p>
                            </button>
                        </div>
                    </div>
                </div>
            );

            const renderSignaling = () => {
                const isScanner = view === 'SCAN_HOST' || view === 'SCAN_JOIN';
                const isQR = view === 'HOST_WAIT' || view === 'JOIN_WAIT';
                const title = view === 'HOST_WAIT' ? "BROADCASTING" : view === 'SCAN_HOST' ? "SEARCHING..." : view === 'SCAN_JOIN' ? "SCAN REPLY" : "YOUR REPLY";
                return (
                    <div className="flex flex-col app-height p-4 items-center justify-center space-y-6 fade-in relative z-10">
                        <div className="w-full max-w-md glass-panel p-8 relative shadow-[0_0_50px_rgba(200,0,0,0.2)]">
                            <button onClick={() => window.location.reload()} className="absolute top-4 left-4 p-2 bg-black border border-red-900 hover:bg-red-900/50 text-red-500 transition-all"><Icon name="x" size={16} /></button>
                            <div className="text-center mb-8">
                                <h2 className="text-3xl font-title text-red-500 st-glow mb-2">{title}</h2>
                                <p className="text-sm text-zinc-500 font-mono tracking-widest uppercase">{isScanner ? "Align camera with signal" : "Show this code to peer"}</p>
                            </div>
                            <div className="flex justify-center min-h-[250px] items-center">
                                {isQR && localSignal && (
                                    <div className="space-y-6 w-full">
                                        <QRAnimator data={localSignal} label="ENCRYPTED PACKET" />
                                        {view === 'HOST_WAIT' && (<button onClick={() => setView('SCAN_JOIN')} className="w-full py-4 bg-red-900 hover:bg-red-800 border border-red-500 text-white font-bold font-mono tracking-widest shadow-lg flex items-center justify-center gap-2 uppercase transition-all"><Icon name="scan-eye" /> Signal Received</button>)}
                                    </div>
                                )}
                                {isScanner && (
                                    <div className="w-full space-y-4">
                                        <QRScanner onScan={handleScannedChunk} />
                                        {scanProgress > 0 && scanProgress < 100 && (<div className="w-full bg-black h-2 border border-red-900"><div className="h-full bg-red-600 transition-all" style={{width: `${scanProgress}%`}}></div></div>)}
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="font-mono text-xs text-red-700 bg-black border border-red-900/50 px-4 py-2 uppercase tracking-widest blink">{logs[logs.length-1] || "SYSTEM_READY"}</div>
                    </div>
                );
            };

            const renderChat = () => (
                <div className="app-height bg-black flex flex-col overflow-hidden relative z-10">
                    <header className="px-6 py-4 bg-zinc-900/90 backdrop-blur-md flex items-center justify-between shadow-lg z-10 shrink-0 border-b-2 border-red-900">
                        <div className="flex items-center gap-4 cursor-pointer group max-w-4xl w-full mx-auto justify-between">
                            <div className="flex items-center gap-4" onClick={() => setShowVerify(true)}>
                                <div className="w-12 h-12 rounded-full border-2 border-red-600 bg-black flex items-center justify-center text-red-500 font-bold text-2xl shadow-[0_0_15px_rgba(255,0,0,0.5)] group-hover:scale-110 transition-transform">{fingerprint.current?.emoji.substring(0,2)}</div>
                                <div>
                                    <h2 className="font-bold text-red-500 text-lg group-hover:text-white transition-colors font-title tracking-wide">HAWKINS AV CLUB</h2>
                                    <p className="text-[10px] text-zinc-500 font-mono tracking-[0.2em] flex items-center gap-1 uppercase"><Icon name="lock" size={10} /> SECURE LINE</p>
                                </div>
                            </div>
                            <div className="flex gap-3">
                                <button onClick={() => startCall(false)} disabled={callStatus !== 'IDLE'} className={`p-3 border-2 transition-all ${callStatus !== 'IDLE' ? 'opacity-30 cursor-not-allowed border-zinc-800 text-zinc-600' : 'text-zinc-400 border-zinc-700 hover:border-red-500 hover:text-red-500 bg-black'}`}><Icon name="phone" size={20} /></button>
                                <button onClick={() => startCall(true)} disabled={callStatus !== 'IDLE'} className={`p-3 border-2 transition-all ${callStatus !== 'IDLE' ? 'opacity-30 cursor-not-allowed border-zinc-800 text-zinc-600' : 'text-zinc-400 border-zinc-700 hover:border-red-500 hover:text-red-500 bg-black'}`}><Icon name="video" size={20} /></button>
                                <button onClick={() => window.location.reload()} className="p-3 text-red-900 border-2 border-red-900 hover:border-red-500 hover:text-red-500 bg-black transition-all"><Icon name="log-out" size={20} /></button>
                            </div>
                        </div>
                    </header>
                    <div className="flex-1 overflow-y-auto p-6 space-y-6 bg-transparent scroll-smooth font-mono">
                        <div className="max-w-4xl mx-auto w-full space-y-4">
                            {messages.map((m) => (m.type === 'SYS' ? (<div key={m.id} className="msg-sys"><span className="sys-pill">{m.text}</span></div>) : (<div key={m.id} className={`flex ${['TX', 'TX_FILE'].includes(m.type) ? 'justify-end' : 'justify-start'} animate-fade-in`}><div className={`msg-bubble ${['TX', 'TX_FILE'].includes(m.type) ? 'msg-me' : 'msg-other'} shadow-md ${['FILE', 'TX_FILE'].includes(m.type) ? 'min-w-[260px]' : 'min-w-[80px]'}`}>{['FILE', 'TX_FILE'].includes(m.type) ? (<><div className="flex items-center gap-2 mb-2 pb-2 border-b border-white/20"><Icon name={m.mimeType?.startsWith('image') ? 'image' : m.mimeType?.startsWith('video') ? 'video' : m.mimeType?.startsWith('audio') ? 'mic' : 'file'} size={14} className="opacity-70" /><span className="font-bold text-xs opacity-90 truncate max-w-[180px] uppercase tracking-wider">{m.text}</span></div>{renderMediaContent(m)}</>) : (m.text)}<div className="text-[10px] mt-2 opacity-60 text-right font-mono flex justify-end gap-1 items-center uppercase tracking-widest">{new Date(m.id).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}{['TX', 'TX_FILE'].includes(m.type) && <Icon name="check" size={12} />}</div></div></div>)))}
                            <div ref={chatEndRef}></div>
                        </div>
                    </div>
                    {showEmoji && (<div className="absolute bottom-20 left-4 bg-black border border-red-900 p-2 shadow-2xl z-20 grid grid-cols-4 gap-2 animate-fade-in">{EMOJIS.map(e => (<button key={e} onClick={() => { setMsgText(p => p + e); setShowEmoji(false); }} className="text-2xl p-2 hover:bg-zinc-900 rounded-sm transition-colors grayscale hover:grayscale-0">{e}</button>))}</div>)}
                    {fileProgress > 0 && (<div className="h-2 bg-black w-full shrink-0 border-t border-red-900"><div className="h-full bg-red-600 transition-all duration-100" style={{width: `${fileProgress}%`}}></div></div>)}
                    <div className="bg-zinc-900 border-t-2 border-red-900 z-10 relative shadow-[0_-5px_20px_rgba(0,0,0,0.5)]">
                        <div className="max-w-4xl mx-auto w-full p-4 flex items-center gap-3 shrink-0 pb-safe">
                            {!isRecordingAudio ? (<><button onClick={() => setShowEmoji(!showEmoji)} className={`p-3 rounded-sm transition-colors border border-transparent ${showEmoji ? 'text-red-500 border-red-900 bg-black' : 'text-zinc-500 hover:text-red-500 hover:bg-black'}`}><Icon name="smile" size={24} /></button><button onClick={() => fileInputRef.current?.click()} className="p-3 rounded-sm text-zinc-500 hover:text-red-500 hover:bg-black transition-colors"><Icon name="paperclip" size={24} /><input type="file" ref={fileInputRef} className="hidden" onChange={handleFileSelect} /></button><div className="flex-1 bg-black border border-zinc-700 rounded-sm flex items-center px-4 py-3 hover:border-red-500 transition-colors focus-within:ring-1 focus-within:ring-red-500 shadow-inner"><input value={msgText} onChange={e => setMsgText(e.target.value)} onKeyDown={e => e.key === 'Enter' && sendMessage()} type="text" placeholder="TRANSMIT MESSAGE..." className="bg-transparent border-none outline-none text-red-100 w-full placeholder-zinc-700 text-lg font-mono uppercase" autoComplete="off" />{msgText.length > 0 && (<button onClick={() => setShowCamera(true)} className="ml-2 text-zinc-600 hover:text-red-500"><Icon name="camera" size={20} /></button>)}</div>{msgText ? (<button onClick={sendMessage} className="p-3 bg-red-800 text-black border border-red-600 hover:bg-red-600 hover:scale-105 transition-all"><Icon name="send-horizontal" size={24} /></button>) : (<div className="flex gap-2"><button onClick={() => setShowCamera(true)} className="p-3 text-zinc-500 hover:text-red-500 hover:bg-black transition-colors border border-transparent hover:border-red-900"><Icon name="camera" size={24} /></button><button onClick={startAudioRecord} className="p-3 bg-zinc-800 text-zinc-400 hover:bg-red-900 hover:text-red-100 transition-all border border-zinc-700 hover:border-red-500"><Icon name="mic" size={24} /></button></div>)}</>) : (<div className="flex-1 flex items-center gap-4 bg-black border border-red-500 p-3 animate-pulse"><div className="w-3 h-3 bg-red-600 rounded-full animate-ping"></div><span className="text-red-500 font-mono font-bold flex-1 tracking-widest text-lg">RECORDING {formatTime(audioTimer)}</span><button onClick={() => setIsRecordingAudio(false)} className="text-zinc-500 text-xs uppercase font-bold px-4 py-2 hover:text-white hover:bg-zinc-900 border border-zinc-700">CANCEL</button><button onClick={stopAudioRecord} className="p-2 bg-red-600 text-black shadow-lg hover:scale-110 transition-transform"><Icon name="send-horizontal" size={24} /></button></div>)}
                        </div>
                    </div>
                    {showVerify && fingerprint.current && (<IdentityModal fingerprint={fingerprint.current} onClose={() => setShowVerify(false)} />)}
                    {showCamera && (<CameraModal onClose={() => setShowCamera(false)} onCapture={processAndSendFile} />)}
                    {callStatus !== 'IDLE' && (<CallOverlay status={callStatus} localStream={localStream} remoteStream={remoteStream} isVideo={isVideoCall} onAnswer={answerCall} onHangup={endCall} onToggleMute={toggleMute} onToggleVideo={toggleVideo} />)}
                </div>
            );

            if(view === 'HOME') return <><div className="atmosphere"><div className="grain"></div><div className="vignette"></div></div><AshParticles />{renderHome()}</>;
            if(view === 'CHAT') return <><div className="atmosphere"><div className="grain"></div><div className="vignette"></div></div>{renderChat()}</>;
            return <><div className="atmosphere"><div className="grain"></div><div className="vignette"></div></div>{renderSignaling()}</>;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
